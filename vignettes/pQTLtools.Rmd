---
title: "An Overview of pQTLtools"
output:
  rmarkdown::html_vignette:
    check_title: false
    fig_caption:  true
    mathjax:  default
    section_numbering: true
    toc: true
    toc_depth: 2
bibliography: refs.bib
vignette: >
  %\VignetteIndexEntry{An Overview of pQTLtools}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
set.seed(0)
knitr::opts_chunk$set(
  out.extra = 'style="display:block; margin: auto"',
  fig.align = "center",
  fig.path = "pQTLtools/",
  collapse = TRUE,
  comment = "#>",
  dev = "png")
```

```{r, message=FALSE, warning=FALSE}
pkgs <- c("GenomicRanges", "TwoSampleMR", "biomaRt", "coloc", "dplyr", "gap", "ggplot2",
          "httr", "karyoploteR", "knitr", "pQTLtools", "rGREAT", "readr", "regioneR", "seqminer")
for (p in pkgs) if (length(grep(paste("^package:", p, "$", sep=""), search())) == 0) {
    if (!requireNamespace(p)) warning(paste0("This vignette needs package `", p, "'; please install"))
}
invisible(suppressMessages(lapply(pkgs, require, character.only=TRUE)))
```

## cis/trans classification
```{r cistrans, fig.cap="cis/trans classification", fig.height=7, fig.width=7}
options(width=200)
f <- file.path("~","pQTLtools","tests","INF1.merge")
merged <- read.delim(f,as.is=TRUE)
hits <- merge(merged[c("CHR","POS","MarkerName","prot","log10p")],
              inf1[c("prot","uniprot")],by="prot") %>%
        mutate(log10p=-log10p)
names(hits) <- c("prot","Chr","bp","SNP","log10p","uniprot")
cistrans <- cis.vs.trans.classification(hits,inf1,"uniprot")
cis.vs.trans <- with(cistrans,data)
kable(with(cistrans,table),caption="Table 1. cis/trans classification")
with(cistrans,total)
circos.cis.vs.trans.plot(hits=f,inf1,"uniprot")
```

A more recent implementation is the `qtlClassifier` function. For this example we have,

```{r qtlClassifier, fig.cap="cis/trans classification", fig.height=7, fig.width=7}
options(width=200)
geneSNP <- merge(merged[c("prot","MarkerName")],inf1[c("prot","gene")],by="prot")[c("gene","MarkerName","prot")]
SNPPos <- merged[c("MarkerName","CHR","POS")]
genePos <- inf1[c("gene","chr","start","end")]
cvt <- qtlClassifier(geneSNP,SNPPos,genePos,1e6)
kable(head(cvt))
cistrans.check <- merge(cvt[c("gene","MarkerName","Type")],cis.vs.trans[c("p.gene","SNP","cis.trans")],
                        by.x=c("gene","MarkerName"),by.y=c("p.gene","SNP"))
with(cistrans.check,table(Type,cis.trans))
```

This is used to generate 2d-pQTL plot
```{r qtl2dplot, fig.cap="2d pQTL plot", fig.height=8}
t2d <- qtl2dplot(cis.vs.trans,xlab="pQTL position",ylab="Gene position")
```
whose result can be also viewed in a 2-d plotly style,
```{r qtl2dplotly, fig.cap="2d pQTL plotly", fig.height=8, fig.width=8, plotly=TRUE}
fig2d <- qtl2dplotly(cis.vs.trans,xlab="pQTL position",ylab="Gene position")
fig2d
# We can save the figure for a browser independently
htmlwidgets::saveWidget(fig2d,file="fig2d.html")
```
and 3-d counterpart
```{r qtl3dplotly, fig.cap="3d pQTL plotly", fig.height=8, fig.width=8, plotly=TRUE}
fig3d <- qtl3dplotly(cis.vs.trans,zmax=300,qtl.prefix="pQTL:",xlab="pQTL position",ylab="Gene position")
fig3d
# We can save the figure for a browser independently
htmlwidgets::saveWidget(fig3d,file="fig3d.html")
```
and ideogram (biomaRt is not always on so we include the plot below)
```r
f <- file.path("~","pQTLtools","tests","INF1.merge")
INF1_merge <- read.delim(f)[c("Chrom","Start","End","prot","MarkerName")]
INF1_merge_cvt <- merge(INF1_merge,cis.vs.trans,by.x=c("prot","MarkerName"),by.y=c("prot","SNP"))
ord <- with(INF1_merge_cvt,order(Chr,bp))
INF1_merge_cvt <- INF1_merge_cvt[ord,]

set_config(config(ssl_verifypeer = 0L))
mart <- useMart(biomart = "ensembl", dataset = "hsapiens_gene_ensembl")
attrs <- c("hgnc_symbol", "chromosome_name", "start_position", "end_position", "band")
hgnc <- vector("character",180)
for(i in 1:180)
{
  v <- with(INF1_merge_cvt[i,],paste0(Chr,":",bp,":",bp))
  g <- subset(getBM(attributes = attrs, filters="chromosomal_region", values=v, mart=mart),!is.na(hgnc_symbol))
  hgnc[i] <- paste(g[["hgnc_symbol"]],collapse=";")
  cat(i,g[["hgnc_symbol"]],hgnc[i],"\n")
}
INF1_merge_cvt <- within(INF1_merge_cvt,{
  hgnc <- hgnc
  hgnc[cis] <- p.gene[cis]
})

with(INF1_merge_cvt, {
  png("karyoplot.png",res= 300, units="in", width=12, height=20)
  sentinels <- toGRanges(Chr,bp-1,bp,labels=hgnc)
  cis.regions <- toGRanges(Chr,cis.start,cis.end)
  loci <- toGRanges(Chr,Start,End)
  colors <- c("red","blue")
  seqlevelsStyle(sentinels) <- "UCSC"
  kp <- plotKaryotype(genome="hg19",chromosomes=levels(seqnames(sentinels)))
  kpAddBaseNumbers(kp)
  kpPlotRegions(kp,data=loci,r0=0.05,r1=0.15,border="black")
  kpPlotMarkers(kp, data=sentinels, labels=hgnc, text.orientation="vertical",
                cex=0.5, y=0.3*seq_along(hgnc)/length(hgnc), srt=30,
                ignore.chromosome.ends=TRUE,
                adjust.label.position=TRUE, label.color=colors[2-cis], label.dist=0.002,
                cex.axis=3, cex.lab=3)
  legend("bottomright", bty="n", pch=c(19,19), col=colors, pt.cex=0.4,
         legend=c("cis", "trans"), text.col=colors, cex=0.8, horiz=FALSE)
# panel <- toGRanges(p.chr,p.start,p.end,labels=p.gene)
# kpPlotLinks(kp, data=loci, data2=panel, col=colors[2-cis])
# dev.off()
})
```
```{r karyoplot, echo=FALSE, fig.cap="Karyoplot", fig.height=12, fig.width=8}
include_graphics('karyoplot.png',dpi=300)
```

## Genomic regions enrichment analysis

It is now considerably easier with Genomic Regions Enrichment of Annotations Tool (GREAT).

```{r GREAT, fig.cap="GREAT plots", fig.height=6, fig.width=8, results='hide', warning=FALSE}
post <- function(regions)
{
  job <- submitGreatJob(get(regions), species="hg19", version="3.0.0")
  et <- getEnrichmentTables(job,download_by = 'tsv')
  tb <- do.call('rbind',et)
  write.table(tb,file=paste0(regions,".tsv"),quote=FALSE,row.names=FALSE,sep="\t")
  invisible(list(job=job,tb=tb))
}

M <- 1e+6
INF1_merge <- read.delim(file.path("~","pQTLtools","tests","INF1.merge")) %>%
              dplyr::mutate(chr=Chrom, start=POS-M, end=POS+M) %>%
              dplyr::mutate(start=if_else(start<0,0,start)) %>%
              dplyr::select(prot,MarkerName,chr,start,end)
cistrans <- dplyr::select(INF1_merge, chr,start,end) %>%
            dplyr::arrange(chr,start,end) %>%
            dplyr::distinct()
# All regions
cistrans.post <- post("cistrans")
job <- with(cistrans.post,job)
plotRegionGeneAssociationGraphs(job,type=c(1,3))
availableOntologies(job)
# plot of the top term
par(mfcol=c(3,1))
plotRegionGeneAssociationGraphs(job, ontology="GO Molecular Function",
                                termID="GO:0005126", type=c(1,3))
plotRegionGeneAssociationGraphs(job, ontology="GO Biological Process",
                                termID="GO:0009611", type=c(1,3))
plotRegionGeneAssociationGraphs(job, ontology="GO Cellular Component",
                                termID="GO:0005615", type=c(1,3))
# Specific regions
IL12B <- dplyr::filter(INF1_merge,prot=="IL.12B") %>% select(chr,start,end)
KITLG <- dplyr::filter(INF1_merge,prot=="SCF") %>% select(chr,start,end)
TNFSF10 <- dplyr::filter(INF1_merge,prot=="TRAIL") %>% select(chr,start,end)
tb_all <- data.frame()
for (r in c("IL12B","KITLG","TNFSF10"))
{
  r.post <- post(r)
  tb_all <- rbind(tb_all,data.frame(gene=r,with(r.post,tb)))
}
write.table(tb_all,file="IL12B-KITLG-TNFSF10.tsv",quote=FALSE,row.names=FALSE,sep="\t")
```

The top terms at Binomial p=1e-5 could be extracted as follows,
```{r, echo=FALSE}
options(width=100)
great3 <- read.delim("IL12B-KITLG-TNFSF10.tsv") %>% filter(BinomP<=1e-5) %>% mutate(ID=gsub(":",": ",ID))
great <- read.delim("cistrans.tsv") %>% filter(BinomBonfP<=1e-8) %>% mutate(ID=gsub(":",": ",ID))
kable(great3,caption="Table 2. GREAT IL12B-KITLG-TNFSF10 results")
unlink("IL12B-KITLG-TNFSF10.tsv")
unlink("IL12B.tsv")
unlink("KITLG.tsv")
unlink("TNFSF10.tsv")
unlink("cistrans.tsv")
```

## eQTL Catalog for colocalisation analysis

See example associated with `import_eQTLCatalogue`. A related function is `import_OpenGWAS` used to fetch data from OpenGWAS. The cis-pQTLs and 1e+6 
flanking regions were considered and data are actually fetched from files stored locally. For illustration, only the first sentinel was used.

```r
INF <- Sys.getenv("INF")
HPC_WORK <- Sys.getenv("HPC_WORK")
f <- file.path(system.file(package="pQTLtools"),"eQTL-Catalogue","hg19ToHg38.over.chain")
chain <- rtracklayer::import.chain(f)
gwasvcf::set_bcftools(file.path(HPC_WORK,"bin","bcftools"))
f <- file.path(system.file(package="pQTLtools"),"eQTL-Catalogue","tabix_ftp_paths_gtex.tsv")
tabix_paths <- read.delim(f, sep = "\t", header = TRUE, stringsAsFactors = FALSE) %>%
               dplyr::as_tibble()
f <- file.path(system.file(package="pQTLtools"),"eQTL-Catalogue",
               "tabix_ftp_paths_gtex.tsv")
imported_tabix_paths <- within(read.delim(f, stringsAsFactors = FALSE) %>%
                        dplyr::as_tibble(),
      {ftp_path <- gsub("ftp://ftp.ebi.ac.uk/pub/databases/spot/eQTL/csv/GTEx_V8/ge",
                        paste0("~","/rds/public_databases/GTEx/csv"),ftp_path)})
M <- 1e6
sentinels <- subset(cis.vs.trans,cis)

liftRegion <- function(x,chain,flanking=1e6)
{
  gr <- with(x,GenomicRanges::GRanges(seqnames=chr,IRanges::IRanges(start,end))+flanking)
  seqlevelsStyle(gr) <- "UCSC"
  gr38 <- rtracklayer::liftOver(gr, chain)
  chr <- colnames(table(seqnames(gr38)))
  chr <- gsub("chr","",chr)
  start <- min(unlist(start(gr38)))
  end <- max(unlist(end(gr38)))
  invisible(list(chr=chr,start=start,end=end,region=paste0(chr,":",start,"-",end)))
}

sumstats <- function(prot,chr,region37)
{
  cat("GWAS sumstats\n")
  f <- file.path(INF,"METAL/gwas2vcf",paste0(prot,".vcf.gz"))
  gwas_stats <- gwasvcf::query_gwas(f, chrompos = region37)
  gwas_stats <- gwasvcf::vcf_to_granges(gwas_stats) %>%
                keepSeqlevels(chr) %>%
                renameSeqlevels(paste0("chr",chr))
  gwas_stats_hg38 <- rtracklayer::liftOver(gwas_stats, chain) %>%
                     unlist() %>%
                     renameSeqlevels(chr) %>%
                     dplyr::as_tibble() %>%
                     dplyr::transmute(chromosome = seqnames,
                                      position = start, REF, ALT, AF, ES, SE, LP, SS) %>%
                     dplyr::mutate(id = paste(chromosome, position, sep = ":")) %>%
                     dplyr::mutate(MAF = pmin(AF, 1-AF)) %>%
                     dplyr::group_by(id) %>%
                     dplyr::mutate(row_count = n()) %>%
                     dplyr::ungroup() %>%
                     dplyr::filter(row_count == 1)
}

coloc <- function(gwas_stats_hg38,ensGene,region38)
{
  cat("c. GTEx_v8 imported eQTL datasets\n")
  rnaseq_df <- dplyr::filter(imported_tabix_paths, quant_method == "ge") %>%
               dplyr::mutate(qtl_id = paste(study, qtl_group, sep = "_"))
  ftp_path_list <- setNames(as.list(rnaseq_df$ftp_path), rnaseq_df$qtl_id)
  hdr <- file.path(system.file(package="pQTLtools"),"eQTL-Catalogue","column_names.GTEx")
  column_names <- names(read.delim(hdr))
  safe_import <- purrr::safely(import_eQTLCatalogue)
  summary_list <- purrr::map(ftp_path_list, ~safe_import(., region38,
                             selected_gene_id = ensGene, column_names))
  result_list <- purrr::map(summary_list, ~.$result)
  result_list <- result_list[!unlist(purrr::map(result_list, is.null))]
  result_filtered <- purrr::map(result_list[lapply(result_list,nrow)!=0],
                                ~dplyr::filter(., !is.na(se)))
  purrr::map_df(result_filtered, ~run_coloc(., gwas_stats_hg38), .id = "qtl_id")
}

sentinel <- sentinels[1,]
isnpid <- within(gap::inv_chr_pos_a1_a2(sentinel[["SNP"]]),
{
    chr <- gsub("chr","",chr)
    pos <- as.integer(pos)
    start <- pos-M
    if (start<0) start <- 0
    end <- pos+M
})
chr <- with(isnpid,chr)
region37 <- with(isnpid, paste0(chr,":",start,"-",end))
ensRegion37 <- with(subset(inf1,prot==sentinel[["prot"]]),paste0(chr,":",start,"-",end))
region38 <- with(liftRegion(isnpid,chain),region)
ensGene <- subset(inf1,prot==sentinel[["prot"]])[["ensembl_gene_id"]]
ensRegion38 <- with(liftRegion(subset(inf1,prot==sentinel[["prot"]]),chain),region)
f <- file.path("~","pQTLtools","tests",with(sentinel,paste0(prot,"-",SNP,".rda")))
gwas_stats_hg38 <- sumstats(sentinel[["prot"]],chr,region37)
coloc_df_imported <- coloc(gwas_stats_hg38,ensGene,region38)
save(gwas_stats_hg38,sentinel,coloc_df_imported,file=f)
```

```{r coloc, fig.cap="Association plot", fig.height=7, fig.width=8, echo=FALSE}
load(file.path("~","pQTLtools","tests","OPG-chr8:120081031_C_T.rda"))
ggplot2::ggplot(gwas_stats_hg38, aes(x = position, y = LP)) +
ggplot2::theme_bw() +
ggplot2::geom_point() +
ggplot2::ggtitle(with(sentinel,paste0(prot,"-",SNP," association plot")))
if (nrow(coloc_df_imported)>0)
{
   dplyr::arrange(coloc_df_imported, -PP.H4.abf)
   ggplot(coloc_df_imported, aes(x = PP.H4.abf)) +
   ggplot2::theme_bw() +
   geom_histogram() +
   ggtitle(with(sentinel,paste0(prot,"-",SNP," PP4 histogram"))) +
   xlab("PP4") + ylab("Frequency")
}
ktitle <- with(sentinel,paste0("Table 3. Colocalisation results for ",prot,"-",SNP))
kable(coloc_df_imported, caption=ktitle)
```

The function `sumstats()` obtained meta-analysis summary statistics (in build 37 and therefore lifted over to build 38) to be used in colocalisation 
analysis.  The output are saved in the `.RDS` files. Note that `ftp_path` changes from eQTL Catalog to local files.

## pQTL-based Mendelian Randomisation (MR)

The function `pqtlMR` is derived from @zheng20. It has an attractive feature that multiple pQTLs
can be used together for conducting MR with a list of outcomes from MR-Base. For generic applications
the `run_TwoSampleMR()` function can be used.

```{r, warning=FALSE}
f <- file.path(system.file(package="pQTLtools"),"tests","Ins.csv")
ivs <- format_data(read.csv(f))
caption4 <- "Table 4. ABO/LIFR variants and CHD/FEV1"
kable(ivs, caption=paste(caption4,"(instruments)"))
ids <- c("ieu-a-7","ebi-a-GCST007432")
pqtlMR(ivs, ids)
result <- read.delim("pQTL-combined-result.txt",header=TRUE)
kable(result,caption=paste(caption4, "(result)"))
single <- read.delim("pQTL-combined-single.txt",header=TRUE)
kable(subset(single,!grepl("All",SNP)), caption=paste(caption4, "(single)"))
invisible(sapply(c("harmonise","result","single"),
                 function(x) unlink(paste0("pQTL-combined-",x,".txt"))))
```

## run_TwoSampleMR

The function has similiarity to @dt18. The documentation example is quoted here,

```{r run_TwoSampleMR, fig.cap="Two-sample MR", fig.height=7, fig.width=7, results='hide', warning=FALSE}
outcomes <- "ebi-a-GCST007432"
prot <- "MMP.10"
type <- "cis"
f <- paste0(prot,"-",type,".mrx")
d <- read.table(file.path(system.file(package="pQTLtools"),"tests",f),
                header=TRUE)
exposure <- format_data(within(d,{P=10^logP}), phenotype_col="prot", snp_col="rsid",
                        chr_col="Chromosome", pos_col="Posistion",
                        effect_allele_col="Allele1", other_allele_col="Allele2",
                        eaf_col="Freq1", beta_col="Effect", se_col="StdErr",
                        pval_col="P", log_pval=FALSE,
                        samplesize_col="N")
clump <- clump_data(exposure)
outcome <- extract_outcome_data(snps=exposure$SNP,outcomes=outcomes)
harmonise <- harmonise_data(clump,outcome)
prefix <- paste(outcomes,prot,type,sep="-")
run_TwoSampleMR(harmonise, mr_plot="pQTLtools", prefix=prefix)
```

The output is contained in individual `.txt` files, together with the scatter, forest, funnel and leave-one-out plots.

```{r, echo=FALSE}
caption5 <- "Table 5. MMP.10 variants and FEV1"
kable(read.delim(paste0(prefix,"-result.txt"),header=TRUE),caption=paste(caption5, "(result)"))
kable(read.delim(paste0(prefix,"-heterogeneity.txt"),header=TRUE),caption=paste(caption5,"(heterogeneity)"))
kable(read.delim(paste0(prefix,"-pleiotropy.txt"),header=TRUE),caption=paste(caption5,"(pleiotropy)"))
kable(read.delim(paste0(prefix,"-single.txt"),header=TRUE),caption=paste(caption5,"(single)"))
kable(read.delim(paste0(prefix,"-loo.txt"),header=TRUE),caption=paste(caption5,"(loo)"))
for (x in c("result","heterogeneity","pleiotropy","single","loo")) unlink(paste0(prefix,"-",x,".txt"))
```

## MR using cis, trans and cis+trans (pan) instruments

This is illustrated with IL-12B.

```{r mr, fig.cap="MR with cis, trans and cis+trans variants of IL-12B", fig.height=9}
efo <- read.delim(file.path("~","pQTLtools","tests","efo.txt")) %>%
       dplyr::mutate(x=1:n()) %>%
       dplyr::select(MRBASEID,trait,x)
d3 <- read.delim(file.path("~","pQTLtools","tests","efo-result.txt")) %>%
      dplyr::filter(exposure=="IL.12B") %>%
      dplyr::mutate(MRBASEID=unlist(lapply(strsplit(outcome,"id:"),"[",2)),y=b) %>%
      dplyr::select(-outcome,-method) %>%
      left_join(efo) %>%
      dplyr::arrange(cistrans)
kable(head(d3[c("MRBASEID","trait","cistrans","nsnp","b","se","pval")],29),caption="Table 6. MR with IL-12B variants")
p <- ggplot2::ggplot(d3,aes(y = trait, x = y))+
     ggplot2::theme_bw()+
     ggplot2::geom_point()+
     ggplot2::facet_wrap(~cistrans,ncol=3,scales="free_x")+
     ggplot2::geom_segment(aes(x = b-1.96*se, xend = b+1.96*se, yend = trait))+
     ggplot2::geom_vline(lty=2, aes(xintercept=0), colour = 'red')+
     ggplot2::xlab("Effect size")+
     ggplot2::ylab("")
p
```

## Literature on pQTLs

Those as identified by @sun18 and @suhre20 are included as EndNote libraries.

## UniProt IDs

The function `uniprot2ids` converts UniProt IDs to others.

## References
